1. Делим массив а до положения, когда в нем не остается до 3 чисел.
2. Сортируем эти части.

// делим массив а, пока там не осталось 3 элемента
a: 13 6 14 17 10 11 2 15 1 16 3 12 18 5 19 20 9 4 8 7
b:
p(a) = 11;

ra pb ra ra pb ra pb ra pb ra pb ra ra pb ra ra pb pb pb pb
a: 13 14 17 11 15 16 12 18 19 20
b: 7 8 4 9 5 3 1 2 10 6
p(a) = 15;

// продолжаем делить
pb pb ra pb pb ra pb ra ra ra
a: 17 16 18 19 20
b: 12 15 11 14 13 | 7 8 4 9 5 3 1 2 10 6
p(a) = 17;

pb pb | ra ra ra		// место оптимизации
a: 18 19 20
b: 16 17 | 12 15 11 14 13 | 7 8 4 9 5 3 1 2 10 6

// теперь когда в стеке осталось три или меньше элемента
// сортируем их по возврастанию и возвращаем элементы обратно
(стек а отсортирован)
a: 18 19 20
b: 16 17 | 12 15 11 14 13 | 7 8 4 9 5 3 1 2 10 6

// сортируем элементы в б (по убыванию) так как туда улетело два
sb
a: 18 19 20
b: 17 16 | 12 15 11 14 13 | 7 8 4 9 5 3 1 2 10 6

// возвращаем из б в а.
pa pa
a: 16 17 18 19 20
b: 12 15 11 14 13 | 7 8 4 9 5 3 1 2 10 6
p(b) = 13;

// теперь в б элементов больше трех, поэтому делим его по медиане и сортируем дальше
rb pa rb pa pa
a: 13 14 15 | 16 17 18 19 20
b: 7 8 4 9 5 3 1 2 10 6 | 12 11

// элементы в стеке меньше p отправляются в конец массива, поэтому возвращаем их
// вперед на кол-во смещений
rrb rrb
a: 13 14 15 | 16 17 18 19 20
b: 12 11 | 7 8 4 9 5 3 1 2 10 6

// сортируем части так как они поделены с размером до трех
(стэк а отсортирован)(стэк б отсортирован)
a: 13 14 15 | 16 17 18 19 20
b: 12 11 | 7 8 4 9 5 3 1 2 10 6

// возвращаем элементы в б
pb pb pb
a: 16 17 18 19 20
b: 15 14 13 12 11 | 7 8 4 9 5 3 1 2 10 6

// сортировка этой части завершена. возвращаем элементы в а.
// половина чисел после этого действия отсортированы
pa pa pa pa pa
a: 11 12 13 14 15 16 17 18 19 20
b: 7 8 4 9 5 3 1 2 10 6
p(b) = 6;

// теперь будем сортировать стек б. Все, что больше p уходит в a
pa pa rb pa rb rb rb rb pa pa
a: 6 10 9 8 7 | 11 12 13 14 15 16 17 18 19 20
b: 4 5 3 1 2
p(b) = 3;
// здесь по алгоритму надо было бы вернуть значения на место используя rrb,
// но из-за того, что кол-во элементов равно кол-ву инструкций rb, мы это не делаем

// продолжаем делить стек б
pa pa | rb rb rb		// место оптимизации
a: 5 4 | 6 10 9 8 7 | 11 12 13 14 15 16 17 18 19 20
b: 3 1 2

// сортируем два элемента в а по возрастанию и три из б по убыванию
sa (a sorted) | rb sa rrb (b sorted);
a: 4 5 | 6 10 9 8 7 | 11 12 13 14 15 16 17 18 19 20
b: 3 2 1

// возвращаем элементы в б. После этого часть в стеке б отсортирована
pb pb
a: 6 10 9 8 7 | 11 12 13 14 15 16 17 18 19 20
b: 5 4 3 2 1
p(a) = 7;

// теперь в стеке а больше 3 элементов, поэтому делим его. Всё что меньше p
// отправляется в b
pb ra ra ra pb
a: 11 12 13 14 15 16 17 18 19 20 | 10 9 8
b: 7 6 | 5 4 3 2 1

// возвращаем элементы в а ra кол-во раз
rra rra rra
a: 8 9 10 | 11 12 13 14 15 16 17 18 19 20
b: 7 6 | 5 4 3 2 1

// элементы в обоих стеках сортируются
(a sorted) (b sorted)
a: 8 9 10 | 11 12 13 14 15 16 17 18 19 20
b: 7 6 | 5 4 3 2 1

// возвращаем элементы в б. Вторая половина отсортирована
pb pb pb
a: 11 12 13 14 15 16 17 18 19 20
b: 10 9 8 7 6 | 5 4 3 2 1

// оба стека отсортированы, просто кидаем всё в a
pa pa pa pa pa pa pa pa pa pa
a: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
b:
